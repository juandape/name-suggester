#!/usr/bin/env node
// namer-suggester.mjs
import fs from 'fs';
import path from 'path';
import os from 'os';
import inquirer from 'inquirer';
import { parse } from '@babel/parser';
import traverse from '@babel/traverse';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';
import fetch from 'node-fetch'; // Para realizar solicitudes HTTP a APIs de IA

// Obtener la ruta del directorio actual del script
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

import {
  ProgressBar,
  FileContext,
  AnalyzeItem,
} from './types/namerSuggester.type.js';

function walk(
  dir,
  ext = /\.(js|jsx|ts|tsx)$/,
  maxDepth = 10,
  currentDepth = 0
) {
  try {
    // Limitar la profundidad para evitar problemas con directorios muy anidados
    if (currentDepth > maxDepth) {
      console.log(`‚ö†Ô∏è Alcanzada la profundidad m√°xima en: ${dir}`);
      return [];
    }

    const files = fs.readdirSync(dir);
    return files
      .map((f) => path.join(dir, f))
      .flatMap((p) => {
        try {
          const stats = fs.statSync(p);
          if (stats.isDirectory())
            return walk(p, ext, maxDepth, currentDepth + 1);
          if (ext.test(p)) return [p];
          return [];
        } catch (error) {
          console.error(`‚ùå Error accediendo a: ${p}`, error.message);
          return [];
        }
      });
  } catch (error) {
    console.error(`‚ùå Error leyendo directorio: ${dir}`, error.message);
    return [];
  }
}

// Funci√≥n para generar sugerencias de nombres basadas en buenas pr√°cticas
/**
 * Genera sugerencias de nombres basadas en buenas pr√°cticas
 * @param original Nombre original
 * @param type Tipo de identificador
 * @param itemContext Contexto adicional
 * @param fileContext Contexto de archivo
 */
function suggestNames(
  original: string,
  type: string = '',
  itemContext: string = '',
  fileContext: Partial<FileContext> = {}
): string[] {
  const suggestions = [];

  // Normalizar el tipo para facilitar el manejo
  const normalizedType = type.toLowerCase();
  const isFunction =
    normalizedType.includes('function') ||
    normalizedType === 'method' ||
    normalizedType === 'object-method';
  const isReactComponent =
    fileContext.context === 'react-component' && /^[A-Z]/.test(original);

  // Sugerencias basadas en el tipo de identificador
  if (isFunction) {
    // Manejadores de eventos
    if (/handle|process|execute/i.test(original)) {
      suggestions.push(original.replace(/handle/i, 'on'));
      suggestions.push(original.replace(/process/i, 'transform'));
      suggestions.push(original.replace(/execute/i, 'run'));

      if (!original.endsWith('Handler')) {
        suggestions.push(original + 'Handler');
      }
    }

    // Funciones que parecen accesores (getters)
    if (original.startsWith('get') && original.length > 5) {
      suggestions.push(original.replace(/^get/, 'retrieve'));
      suggestions.push(original.replace(/^get/, 'fetch'));
    }

    // Funciones que parecen mutadores (setters)
    if (original.startsWith('set') && original.length > 5) {
      suggestions.push(original.replace(/^set/, 'update'));
      suggestions.push(original.replace(/^set/, 'modify'));
    }

    // Funciones de API o fetch
    if (/api|fetch|load|request/i.test(original)) {
      const resource = original
        .replace(/fetch|get|load|request|api/gi, '')
        .toLowerCase();
      if (resource) {
        suggestions.push(
          `fetch${resource.charAt(0).toUpperCase() + resource.slice(1)}`
        );
        suggestions.push(
          `load${resource.charAt(0).toUpperCase() + resource.slice(1)}`
        );
        suggestions.push(
          `retrieve${resource.charAt(0).toUpperCase() + resource.slice(1)}`
        );
      } else {
        suggestions.push('fetchData', 'loadContent', 'retrieveResources');
      }
    }

    // Funciones de validaci√≥n
    if (/check|validate|verify/i.test(original)) {
      suggestions.push(original.replace(/check/i, 'validate'));
      suggestions.push(
        original.replace(/check|validate|verify/i, 'is') + 'Valid'
      );
      suggestions.push(
        original.replace(/check|validate|verify/i, 'ensure') + 'Valid'
      );
    }

    // Funciones de inicializaci√≥n
    if (/init|start|begin/i.test(original)) {
      suggestions.push(original.replace(/init|start|begin/i, 'initialize'));
      suggestions.push(original.replace(/init|start|begin/i, 'setup'));
      suggestions.push(original.replace(/init|start|begin/i, 'create'));
    }
  }
  // Variables y propiedades
  else {
    // Para variables que parecen guardar datos
    if (/data|info|payload/i.test(original)) {
      suggestions.push('payload');
      suggestions.push('response');
      suggestions.push('result');
      suggestions.push('content');

      // Si es probable que sea una lista
      if (/s$|list$|array$/i.test(original)) {
        suggestions.push('items');
        suggestions.push('collection');
        suggestions.push('elements');
      }
    }

    // Para variables que parecen ser contadores o √≠ndices
    if (/count|index|num|i$|j$/i.test(original) && original.length < 7) {
      suggestions.push('counter');
      suggestions.push('index');
      suggestions.push('position');
    }

    // Para variables que parecen ser flags o estados
    if (/is|has|should|can|flag/i.test(original)) {
      if (!/^(is|has|should|can)/.test(original)) {
        suggestions.push(
          `is${original.charAt(0).toUpperCase() + original.slice(1)}`
        );
        suggestions.push(
          `has${original.charAt(0).toUpperCase() + original.slice(1)}`
        );
      }
    }

    // Para variables temporales o poco descriptivas
    if (original.length < 4 && !/^(id|i|j)$/.test(original)) {
      suggestions.push(`${original}Value`);
      suggestions.push(
        `temp${original.charAt(0).toUpperCase() + original.slice(1)}`
      );
    }
  }

  // Sugerencias espec√≠ficas para React
  if (
    fileContext.context === 'react-component' ||
    fileContext.context === 'react-hooks'
  ) {
    if (isReactComponent) {
      // Componentes React
      if (!/^[A-Z]/.exec(original)) {
        suggestions.push(original.charAt(0).toUpperCase() + original.slice(1));
      }
      if (!original.endsWith('Component') && original.length > 4) {
        suggestions.push(original + 'Component');
      }
    }
    // Hooks personalizados
    else if (
      isFunction &&
      !original.startsWith('use') &&
      normalizedType === 'function'
    ) {
      suggestions.push(
        `use${original.charAt(0).toUpperCase() + original.slice(1)}`
      );
    }
    // Manejadores de eventos en componentes
    else if (
      isFunction &&
      /click|change|submit|input/i.test(original) &&
      !original.startsWith('handle')
    ) {
      suggestions.push(
        `handle${original.charAt(0).toUpperCase() + original.slice(1)}`
      );
      suggestions.push(
        `on${original.charAt(0).toUpperCase() + original.slice(1)}`
      );
    }
    // Estados
    else if (/state|status|value|data/i.test(original) && !isFunction) {
      const stateName = original.replace(/(state|status|value|data)/i, '');
      if (stateName) {
        suggestions.push(
          stateName.charAt(0).toLowerCase() + stateName.slice(1)
        );
        suggestions.push(
          `${stateName.charAt(0).toLowerCase() + stateName.slice(1)}State`
        );
      } else {
        suggestions.push('value', 'state', 'data');
      }
    }
  }

  // Sugerencias espec√≠ficas para testing
  if (fileContext.context === 'testing') {
    if (isFunction && /test|spec|should/i.test(original)) {
      suggestions.push(
        `should${
          original
            .replace(/test|spec|should/i, '')
            .charAt(0)
            .toUpperCase() + original.replace(/test|spec|should/i, '').slice(1)
        }`
      );
      suggestions.push(
        `it${
          original
            .replace(/test|spec|should|it/i, '')
            .charAt(0)
            .toUpperCase() +
          original.replace(/test|spec|should|it/i, '').slice(1)
        }`
      );
    }
  }

  // Eliminar el nombre original y sugerencias duplicadas
  return [...new Set(suggestions)].filter((s) => s !== original);
}

// Funci√≥n para obtener sugerencias usando IA
async function getCopilotSuggestions(
  original: string,
  type: string,
  context: string,
  fileContext: Partial<FileContext>
): Promise<string[]> {
  // Cargar configuraci√≥n
  const aiConfig = loadAIConfig();
  const provider = aiConfig.provider || 'rules';

  // Mostrar configuraci√≥n del proveedor seleccionado
  console.log(`üîß Proveedor de IA configurado: ${provider}`);

  // Construir prompt com√∫n para todos los servicios
  const promptBase = `Eres un experto en nomenclatura de c√≥digo para ${
    fileContext.context || 'JavaScript/TypeScript'
  }.
  Dame 3 a 5 nombres mejores para un${
    type === 'variable' ? 'a' : ''
  } ${type} llamado "${original}"
  en un archivo de tipo ${fileContext.context || 'JavaScript/TypeScript'}.
  Contexto adicional: ${context || 'No disponible'}.
  Importaciones del archivo: ${
    fileContext.imports?.join(', ') || 'No disponibles'
  }.
  Responde SOLO con los nombres alternativos separados por comas, sin explicaciones.`;

  try {
    // 1. Intentar usar GitHub Copilot CLI (primera opci√≥n, m√°s integrada)
    if (provider === 'copilot' || provider === 'auto') {
      try {
        console.log(
          'üîÑ Intentando obtener sugerencias de GitHub Copilot CLI...'
        );
        const prompt = `Sugiere 3 nombres mejores para ${type} llamado "${original}" en un archivo ${
          fileContext.context || 'JavaScript/TypeScript'
        }. Contexto: ${
          context || 'No disponible'
        }. Responde solo con los nombres separados por comas, sin explicaciones adicionales.`;
        const result = execSync(`echo "${prompt}" | gh copilot suggest`, {
          timeout: 8000, // Tiempo de espera aumentado
        });
        const suggestions = result
          .toString()
          .trim()
          .split(',')
          .map((s) => s.trim());

        const validSuggestions = suggestions.filter(
          (s) => s && s !== original && s.length > 0
        );
        if (validSuggestions.length > 0) {
          console.log('‚ú® Sugerencias obtenidas de GitHub Copilot CLI');
          return validSuggestions;
        }
        console.log('‚ö†Ô∏è GitHub Copilot CLI no devolvi√≥ sugerencias v√°lidas');
      } catch (error) {
        // Silenciosamente pasamos al siguiente proveedor
        if (provider === 'copilot') {
          console.log(
            '‚ö†Ô∏è GitHub Copilot CLI no disponible o fall√≥:',
            error.message
          );
        } else {
          console.log(
            '‚ö†Ô∏è GitHub Copilot CLI no disponible, probando otras opciones...'
          );
        }
      }
    }

    // 2. OpenAI (GPT)
    if (provider === 'openai' || provider === 'auto') {
      try {
        const openaiApiKey =
          aiConfig.openai?.apiKey || process.env.OPENAI_API_KEY;

        if (openaiApiKey) {
          console.log('üîÑ Intentando obtener sugerencias de OpenAI...');
          const model = aiConfig.openai?.model || 'gpt-3.5-turbo';
          console.log(`üìä Usando modelo: ${model}`);

          const response = await fetch(
            'https://api.openai.com/v1/chat/completions',
            {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${openaiApiKey}`,
              },
              body: JSON.stringify({
                model: model,
                messages: [
                  {
                    role: 'system',
                    content:
                      'Eres un experto en nomenclatura de c√≥digo. Responde solo con los nombres sugeridos separados por comas, sin explicaciones.',
                  },
                  { role: 'user', content: promptBase },
                ],
                temperature: 0.7,
                max_tokens: 50,
              }),
              // timeout no es parte de RequestInit est√°ndar
            }
          );

          if (!response.ok) {
            throw new Error(
              `API error: ${response.status} ${response.statusText}`
            );
          }

          const data = await response.json();

          const d = data as any;
          if (d.error) {
            throw new Error(
              `OpenAI error: ${d.error.message || JSON.stringify(d.error)}`
            );
          }

          if (d.choices?.[0]?.message) {
            const suggestions = d.choices[0].message.content
              .split(',')
              .map((s: string) => s.trim())
              .filter(
                (s: string) =>
                  s && !s.includes(' ') && s !== original && s.length > 0
              );
            if (suggestions.length > 0) {
              console.log('‚ú® Sugerencias obtenidas de OpenAI');
              return suggestions;
            }
            console.log('‚ö†Ô∏è OpenAI no devolvi√≥ sugerencias v√°lidas');
          }
        } else if (provider === 'openai') {
          console.log(
            '‚ö†Ô∏è Se requiere API key de OpenAI. Config√∫rala con OPENAI_API_KEY o en .ai-config.json'
          );
        }
      } catch (error) {
        if (provider === 'openai') {
          console.log('‚ùå Error con OpenAI:', error.message);
        } else {
          console.log('‚ö†Ô∏è OpenAI no disponible, probando otras opciones...');
        }
      }
    }

    // 3. Anthropic Claude
    if (provider === 'anthropic' || provider === 'auto') {
      try {
        const anthropicApiKey =
          aiConfig.anthropic?.apiKey || process.env.ANTHROPIC_API_KEY;

        if (anthropicApiKey) {
          const model = aiConfig.anthropic?.model || 'claude-instant-1';

          const response = await fetch(
            'https://api.anthropic.com/v1/messages',
            {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'x-api-key': anthropicApiKey,
                'anthropic-version': '2023-06-01',
              },
              body: JSON.stringify({
                model: model,
                messages: [{ role: 'user', content: promptBase }],
                max_tokens: 50,
              }),
            }
          );

          const data = await response.json();

          const d = data as any;
          if (d.content?.[0]?.text) {
            const suggestions = d.content[0].text
              .split(',')
              .map((s: string) => s.trim())
              .filter(
                (s: string) =>
                  s && !s.includes(' ') && s !== original && s.length > 0
              );
            if (suggestions.length > 0) {
              console.log('‚ú® Sugerencias obtenidas de Anthropic Claude');
              return suggestions;
            }
          }
        }
      } catch (error) {
        console.log(
          'Info: Anthropic Claude no disponible o fall√≥:',
          error.message
        );
      }
    }

    // 4. Ollama (modelos locales)
    if (provider === 'ollama' || provider === 'auto') {
      try {
        const endpoint =
          aiConfig.ollama?.endpoint || 'http://localhost:11434/api/generate';
        const model = aiConfig.ollama?.model || 'llama2';

        const response = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: model,
            prompt: promptBase,
            stream: false,
          }),
        });

        const data = await response.json();

        const d = data as any;
        if (d.response) {
          const suggestions = d.response
            .split(',')
            .map((s: string) => s.trim())
            .filter(
              (s: string) =>
                s && !s.includes(' ') && s !== original && s.length > 0
            );
          if (suggestions.length > 0) {
            console.log('‚ú® Sugerencias obtenidas de Ollama (modelo local)');
            return suggestions;
          }
        }
      } catch (error) {
        console.log('Info: Ollama no disponible o fall√≥:', error.message);
      }
    }

    // 5. Google Gemini
    if (provider === 'gemini' || provider === 'auto') {
      try {
        const geminiApiKey =
          aiConfig.gemini?.apiKey || process.env.GEMINI_API_KEY;

        if (geminiApiKey) {
          const model = aiConfig.gemini?.model || 'gemini-pro';
          const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;

          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              contents: [
                {
                  parts: [{ text: promptBase }],
                },
              ],
            }),
          });

          const data = await response.json();

          const d = data as any;
          if (d.candidates?.[0]?.content) {
            const suggestions = d.candidates[0].content.parts[0].text
              .split(',')
              .map((s: string) => s.trim())
              .filter(
                (s: string) =>
                  s && !s.includes(' ') && s !== original && s.length > 0
              );
            if (suggestions.length > 0) {
              console.log('‚ú® Sugerencias obtenidas de Google Gemini');
              return suggestions;
            }
          }
        }
      } catch (error) {
        console.log(
          'Info: Google Gemini no disponible o fall√≥:',
          error.message
        );
      }
    }

    // Si ning√∫n servicio de IA est√° disponible o todos fallan, devolver array vac√≠o
    console.log(
      'Info: Ning√∫n servicio de IA disponible, usando reglas predefinidas.'
    );
    return [];
  } catch (error) {
    console.log('Error obteniendo sugerencias de IA:', error.message);
    return [];
  }
}

async function selectFileOrFolder(startDir = '.'): Promise<string> {
  const rootDirs = ['./apps', './packages', './src'];
  let currentDir = startDir;

  // Iniciar con las carpetas ra√≠z del proyecto si estamos en el nivel superior
  if (startDir === '.') {
    const { selection } = await inquirer.prompt([
      {
        type: 'list',
        name: 'selection',
        message: 'üìÇ Selecciona una carpeta ra√≠z para comenzar:',
        choices: [
          ...rootDirs
            .filter((dir) => fs.existsSync(dir))
            .map((dir) => ({
              name: `üìÅ ${dir}`,
              value: dir,
            })),
          { name: 'üîç Buscar archivo por patr√≥n', value: 'search' },
          { name: 'üìã Especificar ruta manualmente', value: 'manual' },
        ],
      },
    ]);

    // Opciones especiales
    if (selection === 'search') {
      return await searchFileByPattern();
    }

    if (selection === 'manual') {
      const { customPath } = await inquirer.prompt([
        {
          type: 'input',
          name: 'customPath',
          message:
            'üìù Introduce la ruta del archivo o carpeta (relativa al proyecto):',
        },
      ]);

      if (fs.existsSync(customPath)) {
        return customPath;
      } else {
        console.log('‚ùå Ruta no encontrada. Volviendo al men√∫ principal...');
        return selectFileOrFolder();
      }
    }

    currentDir = selection;
  }

  // Navegar de forma recursiva por el sistema de archivos
  while (true) {
    const items = fs.readdirSync(currentDir);

    const dirs = items
      .filter((item) => fs.statSync(path.join(currentDir, item)).isDirectory())
      .map((item) => ({
        name: `üìÅ ${item}/`,
        value: path.join(currentDir, item),
        isDir: true,
      }));

    const files = items
      .filter((item) => {
        const fullPath = path.join(currentDir, item);
        return (
          fs.statSync(fullPath).isFile() && /\.(js|jsx|ts|tsx)$/.test(item)
        );
      })
      .map((item) => ({
        name: `üìÑ ${item}`,
        value: path.join(currentDir, item),
        isDir: false,
      }));

    // Opciones de navegaci√≥n
    const navOptions = [
      { name: '‚¨ÖÔ∏è Volver al directorio anterior', value: 'back', isDir: true },
      { name: 'üè† Volver al inicio', value: 'home', isDir: true },
      {
        name: '‚úÖ Seleccionar este directorio completo',
        value: currentDir,
        isDir: true,
      },
    ];

    if (currentDir !== '.' && path.dirname(currentDir) !== currentDir) {
      navOptions.unshift({
        name: `üìÅ ${path.dirname(currentDir)}/`,
        value: path.dirname(currentDir),
        isDir: true,
      });
    }

    const { selection } = await inquirer.prompt([
      {
        type: 'list',
        name: 'selection',
        message: `üìÇ Navegando: ${currentDir}\nSelecciona un archivo o carpeta:`,
        pageSize: 15,
        choices: [
          ...navOptions,
          new inquirer.Separator('---- Directorios ----'),
          ...dirs,
          new inquirer.Separator('---- Archivos ----'),
          ...files,
        ],
      },
    ]);

    if (selection === 'back') {
      if (
        currentDir === '.' ||
        currentDir === '/' ||
        rootDirs.includes(currentDir)
      ) {
        return selectFileOrFolder();
      }
      currentDir = path.dirname(currentDir);
      continue;
    }

    if (selection === 'home') {
      return selectFileOrFolder();
    }

    // Si seleccionamos un archivo o la opci√≥n de directorio completo, terminamos
    const selectedItem = [...navOptions, ...dirs, ...files].find(
      (item) => item.value === selection
    );

    // Si seleccionamos "Seleccionar este directorio completo"
    if (selection === currentDir) {
      console.log(`\n‚úÖ Seleccionado directorio completo: ${currentDir}`);
      return selection;
    }

    // Si seleccionamos un archivo, terminamos
    if (!selectedItem?.isDir) {
      return selection;
    }

    // Si seleccionamos un directorio para navegar, actualizamos la ruta
    currentDir = selection;
  }
}

// Funci√≥n para buscar archivos por patr√≥n
async function searchFileByPattern(): Promise<string> {
  const { pattern } = await inquirer.prompt([
    {
      type: 'input',
      name: 'pattern',
      message:
        'üîç Introduce un patr√≥n para buscar archivos (ej: "*.component.ts", "user*.ts"):',
    },
  ]);

  const rootDirs = ['./apps', './packages', './src'];
  const results = [];

  for (const rootDir of rootDirs) {
    if (fs.existsSync(rootDir)) {
      findFilesByPattern(rootDir, pattern, results);
    }
  }

  if (results.length === 0) {
    console.log('‚ùå No se encontraron archivos que coincidan con el patr√≥n.');
    return selectFileOrFolder();
  }

  const { selectedFile } = await inquirer.prompt([
    {
      type: 'list',
      name: 'selectedFile',
      message: `üìë Se encontraron ${results.length} archivos. Selecciona uno:`,
      pageSize: 15,
      choices: results.map((file) => ({
        name: file,
        value: file,
      })),
    },
  ]);

  return selectedFile;
}

// Funci√≥n auxiliar para buscar archivos por patr√≥n
function findFilesByPattern(
  dir: string,
  pattern: string,
  results: string[]
): void {
  const files = fs.readdirSync(dir);
  const regex = new RegExp(pattern.replace(/\*/g, '.*'));

  for (const file of files) {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      findFilesByPattern(fullPath, pattern, results);
    } else if (regex.test(file)) {
      results.push(fullPath);
    }
  }
}

function extractFileContext(code: string): FileContext {
  // Extraer comentarios de cabecera y palabras clave para entender contexto
  const headerComments = /^(\/\/.*|\/\*[\s\S]*?\*\/)\s*$/m.exec(code) || [];
  const importMatches = [
    ...code.matchAll(/import\s+.*?\s+from\s+['"](.+?)['"]/g),
  ];
  const imports = importMatches.map((match) => match[1]);
  const reactHooks =
    code.includes('useState') ||
    code.includes('useEffect') ||
    code.includes('useContext') ||
    code.includes('useReducer');
  const isComponent =
    /function\s+[A-Z][a-zA-Z]*\s*\(/g.test(code) ||
    /const\s+[A-Z][a-zA-Z]*\s*=\s*\(?/g.test(code);

  // Detectar contexto general
  let context = 'general';
  if (isComponent) context = 'react-component';
  else if (reactHooks) context = 'react-hooks';
  else if (code.includes('test(') || code.includes('describe('))
    context = 'testing';
  else if (
    code.includes('api') ||
    code.includes('fetch') ||
    code.includes('axios')
  )
    context = 'api';

  return {
    context,
    imports,
    headerComments: headerComments.join(' '),
  };
}

function analyzeFile(filePath: string): {
  results: AnalyzeItem[];
  fileContext: FileContext;
} {
  const code = fs.readFileSync(filePath, 'utf-8');
  const context = extractFileContext(code);

  try {
    const ast = parse(code, {
      sourceType: 'module',
      plugins: ['jsx', 'typescript'],
    });

    const results = [];

    traverse(ast, {
      // Declaraciones de funciones
      FunctionDeclaration(path) {
        const name = path.node.id?.name;
        if (name) {
          // Extraer comentarios justo antes de la funci√≥n para mayor contexto
          const comments =
            path.node.leadingComments
              ?.map((comment) => comment.value)
              .join('\n') || '';
          results.push({
            type: 'function',
            name,
            line: path.node.loc?.start.line,
            context: comments,
          });
        }
      },
      // Variables
      VariableDeclarator(path) {
        const name = path.node.id?.name;
        if (name) {
          // Detectar si es una funci√≥n de flecha
          const isArrowFunction =
            path.node.init?.type === 'ArrowFunctionExpression';
          // Extraer contexto del c√≥digo padre
          const parentContext =
            path.parentPath?.node?.leadingComments
              ?.map((comment) => comment.value)
              .join('\n') || '';

          results.push({
            type: isArrowFunction ? 'arrow-function' : 'variable',
            name,
            line: path.node.loc?.start.line,
            context: parentContext,
          });
        }
      },
      // M√©todos de clase
      ClassMethod(path) {
        const name = path.node.key?.name;
        if (name) {
          results.push({
            type: 'method',
            name,
            line: path.node.loc?.start.line,
            context:
              path.node.leadingComments
                ?.map((comment) => comment.value)
                .join('\n') || '',
          });
        }
      },
      // Propiedades de clase
      ClassProperty(path) {
        const name = path.node.key?.name;
        if (name) {
          results.push({
            type: 'property',
            name,
            line: path.node.loc?.start.line,
            context:
              path.node.leadingComments
                ?.map((comment) => comment.value)
                .join('\n') || '',
          });
        }
      },
      // ObjectMethod (m√©todos dentro de objetos)
      ObjectMethod(path) {
        const name = path.node.key?.name;
        if (name) {
          results.push({
            type: 'object-method',
            name,
            line: path.node.loc?.start.line,
            context:
              path.node.leadingComments
                ?.map((comment) => comment.value)
                .join('\n') || '',
          });
        }
      },
    });

    return { results, fileContext: context };
  } catch (error) {
    console.error(`Error analizando ${filePath}:`, error.message);
    return { results: [], fileContext: context };
  }
}

// Funci√≥n para registrar sugerencias en un archivo log
function logSuggestions(
  filePath: string,
  item: AnalyzeItem,
  suggestions: string[],
  selected: string,
  fileContext: FileContext
): void {
  // Definimos posibles ubicaciones para el archivo de log
  const possibleLogPaths = [
    path.resolve(process.cwd(), 'namer-suggester.log'),
    path.resolve(__dirname, 'namer-suggester.log'),
    path.resolve(os.homedir(), 'namer-suggester.log'),
  ];

  const timestamp = new Date().toISOString();

  const entry = `
## ${timestamp} - ${path.basename(filePath)}
- **Archivo**: \`${filePath}\`
- **Tipo**: ${item.type}
- **L√≠nea**: ${item.line || 'N/A'}
- **Nombre Original**: \`${item.name}\`
- **Contexto**: ${fileContext.context || 'general'}
- **Sugerencias**: ${suggestions.map((s) => `\`${s}\``).join(', ')}
- **Seleccionado**: \`${selected}\`
`;

  let logSuccess = false;

  // Intentar escribir en cada una de las posibles ubicaciones hasta que una funcione
  for (const logFile of possibleLogPaths) {
    try {
      // Crear el encabezado si el archivo no existe
      if (!fs.existsSync(logFile)) {
        try {
          fs.writeFileSync(
            logFile,
            `# Registro de Sugerencias de Nombres\n\n`,
            'utf-8'
          );
        } catch (initError) {
          // Si no se puede crear el archivo, intentar con la siguiente ubicaci√≥n
          continue;
        }
      }

      // A√±adir al archivo existente en lugar de sobrescribir
      fs.appendFileSync(logFile, entry, 'utf-8');
      console.log(`üíæ Registro guardado en: ${logFile}`);
      logSuccess = true;
      break; // Si se logra escribir, salir del bucle
    } catch (error) {
      // Continuar con el siguiente intento
    }
  }

  if (!logSuccess) {
    console.error(
      `‚ùå No se pudo guardar el registro en ninguna ubicaci√≥n. Verificar permisos.`
    );
    // Como √∫ltimo recurso, mostrar una versi√≥n simplificada en consola
    console.log(
      `üìù Resumen de sugerencias para "${item.name}": ${suggestions.join(', ')}`
    );
  }
}

async function showSuggestionsFor(
  results: AnalyzeItem[],
  fileContext: FileContext,
  filePath: string
): Promise<void> {
  //

  for (const item of results) {
    console.log(
      `\nüîç Analizando ${item.type}: "${item.name}" (l√≠nea ${
        item.line || 'N/A'
      })`
    );

    // Obtener sugerencias basadas en las reglas y contexto
    const basicSuggestions = suggestNames(
      item.name,
      item.type,
      item.context,
      fileContext
    );

    console.log(
      `‚öôÔ∏è Reglas predefinidas generaron ${basicSuggestions.length} sugerencias`
    );

    // Intentar obtener sugerencias adicionales de Copilot u otros proveedores de IA
    let copilotSuggestions = [];
    //
    try {
      copilotSuggestions = await getCopilotSuggestions(
        item.name,
        item.type,
        item.context,
        fileContext
      );
      console.log(
        `ü§ñ IA gener√≥ ${copilotSuggestions.length} sugerencias adicionales`
      );
    } catch (error) {
      console.error(`‚ùå Error al obtener sugerencias de IA: ${error.message}`);
    }

    // Combinar sugerencias eliminando duplicados
    const allSuggestions = [
      ...new Set([...basicSuggestions, ...copilotSuggestions]),
    ];

    // Agregar algunas sugerencias m√≠nimas si no se han encontrado
    if (allSuggestions.length === 0) {
      console.log(
        `‚ö†Ô∏è No se encontraron sugerencias para ${item.type} "${item.name}", generando sugerencias b√°sicas...`
      );

      // A√±adir sugerencias gen√©ricas basadas en el tipo
      if (
        item.type === 'function' ||
        item.type === 'method' ||
        item.type === 'arrow-function'
      ) {
        // Funciones y m√©todos
        allSuggestions.push(
          `process${item.name.charAt(0).toUpperCase()}${item.name.slice(1)}`
        );
        allSuggestions.push(
          `handle${item.name.charAt(0).toUpperCase()}${item.name.slice(1)}`
        );

        // Si parece ser un manejador de eventos
        if (
          item.name.includes('click') ||
          item.name.includes('change') ||
          item.name.includes('submit')
        ) {
          allSuggestions.push(
            `on${item.name.charAt(0).toUpperCase()}${item.name.slice(1)}`
          );
          allSuggestions.push(
            `handle${item.name.charAt(0).toUpperCase()}${item.name.slice(1)}`
          );
        }

        // Si parece ser un getter
        if (item.name.startsWith('get')) {
          allSuggestions.push(item.name.replace(/^get/, 'fetch'));
          allSuggestions.push(item.name.replace(/^get/, 'retrieve'));
        }
      } else if (item.type === 'variable' || item.type === 'property') {
        // Variables y propiedades
        allSuggestions.push(`${item.name}Value`);
        allSuggestions.push(`${item.name}Data`);

        // Si parece ser un estado o flag
        if (item.name.includes('is') || item.name.includes('has')) {
          const baseName = item.name.replace(/^(is|has)/, '');
          if (baseName !== item.name) {
            allSuggestions.push(`is${baseName}`);
            allSuggestions.push(`has${baseName}`);
          }
        }

        // Si es muy corta (probablemente poco descriptiva)
        if (item.name.length <= 3) {
          allSuggestions.push(`${item.name}Item`);
          allSuggestions.push(`${item.name}Element`);
        }
      }

      // Siempre asegurar que hay al menos una sugerencia
      if (allSuggestions.length === 0) {
        // Como √∫ltimo recurso, agregar alguna variante del nombre original
        allSuggestions.push(
          `improved${item.name.charAt(0).toUpperCase()}${item.name.slice(1)}`
        );
        allSuggestions.push(
          `better${item.name.charAt(0).toUpperCase()}${item.name.slice(1)}`
        );
        console.log(
          `üîÑ Generadas sugerencias de √∫ltimo recurso para "${item.name}"`
        );
      }
    }

    // Destacar si hay sugerencias de Copilot
    const copilotLabel =
      copilotSuggestions.length > 0 ? ' (incluye sugerencias de Copilot)' : '';

    // Mostrar las sugerencias al usuario
    const { newName } = await inquirer.prompt([
      {
        type: 'list',
        name: 'newName',
        message: `üí° Sugerencias para ${item.type} "${item.name}" (l√≠nea ${
          item.line || 'N/A'
        })${copilotLabel}:`,
        pageSize: 10,
        choices: [
          { name: `${item.name} (mantener)`, value: item.name },
          ...allSuggestions.map((suggestion) => {
            // Marca las sugerencias que vienen de Copilot
            const fromCopilot = copilotSuggestions.includes(suggestion);
            return {
              name: `${suggestion}${fromCopilot ? ' ‚ú®' : ''}`,
              value: suggestion,
            };
          }),
        ],
      },
    ]);

    // Registrar en el log
    logSuggestions(filePath, item, allSuggestions, newName, fileContext);

    const selectedLabel = newName === item.name ? 'mantenido' : 'cambiado a';
    console.log(`‚úÖ Nombre ${selectedLabel}: \`${newName}\`\n`);
  }

  //
}

// Funci√≥n para mostrar estad√≠sticas al final del an√°lisis
function showStats(
  totalFiles: number,
  totalItems: number,
  changedItems: number
): void {
  console.log('\nüìä Estad√≠sticas del an√°lisis:');
  console.log(`üìÇ Archivos analizados: ${totalFiles}`);
  console.log(`üîç Identificadores encontrados: ${totalItems}`);
  console.log(`‚úèÔ∏è Identificadores con sugerencias de cambio: ${changedItems}`);
  console.log(`üìù Se ha creado un registro detallado en 'namer-suggester.log'`);
}

// Funci√≥n para detectar el tipo de proyecto
function detectProjectType(): { projectType: string; framework: string } {
  try {
    // Determinar el tipo de proyecto
    let projectType = 'javascript';
    let framework = 'unknown';

    // Buscar archivos de configuraci√≥n comunes
    const projectRoot = process.cwd();

    // React/Next.js
    if (
      fs.existsSync(path.join(projectRoot, 'next.config.js')) ||
      fs.existsSync(path.join(projectRoot, 'next.config.mjs'))
    ) {
      framework = 'nextjs';
    }
    // React Native
    else if (
      fs.existsSync(path.join(projectRoot, 'app.json')) &&
      fs.existsSync(path.join(projectRoot, 'metro.config.js'))
    ) {
      framework = 'react-native';
    }
    // Vite
    else if (
      fs.existsSync(path.join(projectRoot, 'vite.config.js')) ||
      fs.existsSync(path.join(projectRoot, 'vite.config.ts'))
    ) {
      framework = 'vite';
    }
    // Angular
    else if (fs.existsSync(path.join(projectRoot, 'angular.json'))) {
      framework = 'angular';
    }
    // Monorepo (Turborepo, Nx, Lerna, etc.)
    else if (
      fs.existsSync(path.join(projectRoot, 'turbo.json')) ||
      fs.existsSync(path.join(projectRoot, 'nx.json')) ||
      fs.existsSync(path.join(projectRoot, 'lerna.json'))
    ) {
      projectType = 'monorepo';
    }

    // TypeScript
    const isTypeScript =
      fs.existsSync(path.join(projectRoot, 'tsconfig.json')) ||
      fs.existsSync(path.join(projectRoot, 'tsconfig.base.json'));

    if (isTypeScript) {
      projectType = 'typescript';
    }

    return { projectType, framework };
  } catch (error) {
    console.log('‚ÑπÔ∏è No se pudo determinar el tipo de proyecto:', error.message);
    return { projectType: 'unknown', framework: 'unknown' };
  }
}

// Funci√≥n para cargar configuraci√≥n de IA
function loadAIConfig(): any {
  try {
    // Buscar configuraci√≥n en varios lugares comunes
    const possibleConfigPaths = [
      path.join(__dirname, '.ai-config.json'),
      path.join(process.cwd(), '.ai-config.json'),
      path.join(os.homedir(), '.namer-suggester-ai-config.json'),
    ];

    for (const configPath of possibleConfigPaths) {
      if (fs.existsSync(configPath)) {
        const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
        return config;
      }
    }

    return {
      provider: 'rules', // Por defecto, usar las reglas integradas
      openai: {
        apiKey: process.env.OPENAI_API_KEY,
        model: 'gpt-3.5-turbo',
      },
      anthropic: {
        apiKey: process.env.ANTHROPIC_API_KEY,
        model: 'claude-instant-1',
      },
      ollama: {
        endpoint: 'http://localhost:11434/api/generate',
        model: 'llama2',
      },
      gemini: {
        apiKey: process.env.GEMINI_API_KEY,
        model: 'gemini-pro',
      },
    };
  } catch (error) {
    console.log('‚ö†Ô∏è Error cargando configuraci√≥n de IA:', error.message);
    return { provider: 'rules' };
  }
}

// Funci√≥n para crear configuraci√≥n de IA
async function createAIConfigFile(): Promise<any> {
  try {
    // Determinar la ruta donde se guardar√° la configuraci√≥n
    const configPaths = [
      path.join(__dirname, '.ai-config.json'),
      path.join(process.cwd(), '.ai-config.json'),
      path.join(os.homedir(), '.namer-suggester-ai-config.json'),
    ];

    // Preguntar al usuario d√≥nde quiere guardar la configuraci√≥n
    const { configLocation } = await inquirer.prompt([
      {
        type: 'list',
        name: 'configLocation',
        message: 'üìÇ ¬øD√≥nde deseas guardar la configuraci√≥n de IA?',
        choices: [
          { name: 'En este proyecto (recomendado)', value: 'project' },
          { name: 'En la carpeta de instalaci√≥n', value: 'install' },
          { name: 'En tu directorio de usuario (global)', value: 'global' },
        ],
      },
    ]);

    // Determinar la ruta basada en la selecci√≥n
    let configPath;
    if (configLocation === 'project') {
      configPath = configPaths[1]; // project
    } else if (configLocation === 'install') {
      configPath = configPaths[0]; // install dir
    } else {
      configPath = configPaths[2]; // global
    }

    // Preguntar por el proveedor de IA preferido
    const { provider } = await inquirer.prompt([
      {
        type: 'list',
        name: 'provider',
        message: 'ü§ñ ¬øQu√© proveedor de IA deseas utilizar?',
        choices: [
          { name: 'Autom√°tico (probar todos los disponibles)', value: 'auto' },
          { name: 'GitHub Copilot CLI', value: 'copilot' },
          { name: 'OpenAI (GPT)', value: 'openai' },
          { name: 'Anthropic Claude', value: 'anthropic' },
          { name: 'Ollama (modelos locales)', value: 'ollama' },
          { name: 'Google Gemini', value: 'gemini' },
          { name: 'Solo reglas predefinidas (sin IA)', value: 'rules' },
        ],
      },
    ]);

    // Configuraci√≥n base
    const config: any = {
      provider,
      openai: { apiKey: '', model: 'gpt-3.5-turbo' },
      anthropic: { apiKey: '', model: 'claude-instant-1' },
      ollama: {
        endpoint: 'http://localhost:11434/api/generate',
        model: 'llama2',
      },
      gemini: { apiKey: '', model: 'gemini-pro' },
    };

    // Si se seleccion√≥ un proveedor espec√≠fico (excepto 'auto' y 'rules'), pedir m√°s configuraci√≥n
    if (provider !== 'auto' && provider !== 'rules' && provider !== 'copilot') {
      if (provider === 'openai') {
        const { apiKey, model } = await inquirer.prompt([
          {
            type: 'password',
            name: 'apiKey',
            message: 'üîë Introduce tu API key de OpenAI:',
            mask: '*',
          },
          {
            type: 'list',
            name: 'model',
            message: 'üìä Selecciona el modelo de OpenAI:',
            choices: [
              { name: 'GPT-3.5 Turbo (m√°s r√°pido)', value: 'gpt-3.5-turbo' },
              { name: 'GPT-4 (m√°s potente)', value: 'gpt-4' },
              { name: 'GPT-4 Turbo', value: 'gpt-4-turbo-preview' },
            ],
          },
        ]);

        config.openai.apiKey = apiKey;
        config.openai.model = model;
      } else if (provider === 'anthropic') {
        const { apiKey, model } = await inquirer.prompt([
          {
            type: 'password',
            name: 'apiKey',
            message: 'üîë Introduce tu API key de Anthropic:',
            mask: '*',
          },
          {
            type: 'list',
            name: 'model',
            message: 'üìä Selecciona el modelo de Anthropic:',
            choices: [
              {
                name: 'Claude Instant (m√°s r√°pido)',
                value: 'claude-instant-1',
              },
              { name: 'Claude 2', value: 'claude-2' },
              {
                name: 'Claude 3 Opus (m√°s potente)',
                value: 'claude-3-opus-20240229',
              },
            ],
          },
        ]);

        config.anthropic.apiKey = apiKey;
        config.anthropic.model = model;
      } else if (provider === 'ollama') {
        const { endpoint, model } = await inquirer.prompt([
          {
            type: 'input',
            name: 'endpoint',
            message:
              'üåê URL del endpoint de Ollama (por defecto: http://localhost:11434/api/generate):',
            default: 'http://localhost:11434/api/generate',
          },
          {
            type: 'input',
            name: 'model',
            message:
              'üìä Nombre del modelo de Ollama (ej: llama2, codellama, mistral):',
            default: 'llama2',
          },
        ]);

        config.ollama.endpoint = endpoint;
        config.ollama.model = model;
      } else if (provider === 'gemini') {
        const { apiKey } = await inquirer.prompt([
          {
            type: 'password',
            name: 'apiKey',
            message: 'üîë Introduce tu API key de Google Gemini:',
            mask: '*',
          },
        ]);

        config.gemini.apiKey = apiKey;
      }
    }

    // Guardar la configuraci√≥n
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf-8');
    console.log(`‚úÖ Configuraci√≥n guardada en ${configPath}`);

    return config;
  } catch (error) {
    console.error('‚ùå Error creando configuraci√≥n de IA:', error.message);
    return { provider: 'rules' }; // fallback a reglas b√°sicas
  }
}

async function main(): Promise<void> {
  console.log('\nüîç Namer Suggester - Analizador de nombres');
  console.log('---------------------------------------');
  console.log(
    'Este script analiza tus archivos JavaScript/TypeScript y sugiere mejores nombres para funciones y variables.\n'
  );

  // Verificar dependencias cr√≠ticas
  try {
    require('@babel/parser');
    require('@babel/traverse');
  } catch (depError) {
    console.error('‚ùå Error: Faltan dependencias necesarias.');
    console.log('üîÑ Ejecutando instalador de dependencias...');
    try {
      execSync(
        'npm install @babel/parser @babel/traverse inquirer node-fetch',
        {
          stdio: 'inherit',
        }
      );
      console.log('‚úÖ Dependencias instaladas correctamente.\n');
    } catch (installError) {
      console.error('‚ùå Error instalando dependencias:', installError.message);
      console.log(
        '\n‚ö†Ô∏è Por favor, instala manualmente las dependencias necesarias:'
      );
      console.log(
        'npm install @babel/parser @babel/traverse inquirer node-fetch'
      );
      process.exit(1);
    }
  }

  // Detectar tipo de proyecto
  let projectType = 'javascript';
  let framework = 'unknown';
  try {
    const projectInfo = detectProjectType();
    projectType = projectInfo.projectType;
    framework = projectInfo.framework;
    console.log(`üß∞ Proyecto detectado: ${projectType.toUpperCase()}`);
    if (framework !== 'unknown') {
      console.log(`üõ†Ô∏è Framework: ${framework.toUpperCase()}`);
    }
  } catch (projectError) {
    console.log(
      `‚ö†Ô∏è No se pudo detectar el tipo de proyecto: ${projectError.message}`
    );
    console.log('Continuando con an√°lisis gen√©rico...');
  }

  // Cargar configuraci√≥n de IA
  let aiConfig;
  try {
    aiConfig = loadAIConfig();

    // Mostrar de manera m√°s clara el proveedor de IA
    let providerDescription;
    if (aiConfig.provider === 'auto') {
      providerDescription = 'Autom√°tico (prueba todos los disponibles)';
    } else if (aiConfig.provider === 'rules') {
      providerDescription = 'Reglas predefinidas (sin IA)';
    } else {
      providerDescription = aiConfig.provider.toUpperCase();
    }

    console.log(`ü§ñ Motor de sugerencias: ${providerDescription}\n`);
  } catch (error) {
    console.log(
      '‚ö†Ô∏è No se pudo cargar configuraci√≥n de IA. Usando reglas predefinidas.\n'
    );
    // aiConfig = { provider: 'rules' };
  }

  // Men√∫ principal
  const { action } = await inquirer.prompt([
    {
      type: 'list',
      name: 'action',
      message: 'üîß ¬øQu√© deseas hacer?',
      choices: [
        {
          name: 'üìÇ Analizar archivos y obtener sugerencias de nombres',
          value: 'analyze',
        },
        { name: '‚öôÔ∏è Configurar proveedores de IA', value: 'configure-ai' },
        { name: '‚ùì Ver ayuda', value: 'help' },
        { name: '‚ùå Salir', value: 'exit' },
      ],
    },
  ]);

  if (action === 'exit') {
    console.log('üëã ¬°Hasta pronto!');
    process.exit(0);
  }

  if (action === 'help') {
    showHelp();
    return;
  }

  if (action === 'configure-ai') {
    await createAIConfigFile();
    console.log(
      '‚úÖ Configuraci√≥n completada. Ejecuta nuevamente el programa para analizar archivos.'
    );
    return;
  }

  // Si llegamos aqu√≠, significa que el usuario quiere analizar archivos

  const target = await selectFileOrFolder();
  let files = [];

  try {
    if (fs.statSync(target).isDirectory()) {
      console.log(`\nüìÅ Analizando directorio: ${target}`);
      console.log(
        '‚è≥ Buscando archivos JavaScript/TypeScript... (esto puede tardar un momento)'
      );

      files = walk(target);

      if (files.length === 0) {
        console.log(
          `‚ö†Ô∏è No se encontraron archivos JavaScript/TypeScript en: ${target}`
        );
        console.log(
          'ÔøΩ Intenta seleccionar otra carpeta o un archivo espec√≠fico.'
        );
        process.exit(0);
      }

      console.log(
        `‚úÖ Se encontraron ${files.length} archivos para analizar.\n`
      );

      // Opcional: preguntar si realmente quiere analizar todos los archivos si son muchos
      if (files.length > 20) {
        const { confirm } = await inquirer.prompt([
          {
            type: 'confirm',
            name: 'confirm',
            message: `‚ö†Ô∏è Se encontraron ${files.length} archivos. ¬øDeseas continuar con el an√°lisis?`,
            default: true,
          },
        ]);

        if (!confirm) {
          console.log('üõë Operaci√≥n cancelada por el usuario.');
          process.exit(0);
        }
      }
    } else {
      files = [target];
    }
  } catch (error) {
    console.error(`‚ùå Error accediendo a ${target}:`, error.message);
    process.exit(1);
  }

  // Estad√≠sticas
  let totalItems = 0;
  let changedItems = 0;

  // Crear archivo de log si no existe
  if (!fs.existsSync('namer-suggester.log')) {
    fs.writeFileSync(
      'namer-suggester.log',
      '# Registro de Sugerencias de Nombres\n\n',
      'utf-8'
    );
  }

  // Crear una √∫nica barra de progreso para todo el proceso
  const progress = new ProgressBar(
    files.length,
    'üìä Analizando archivos:',
    'Completado',
    20
  );

  // Analizar cada archivo
  try {
    for (let i = 0; i < files.length; i++) {
      const file = files[i];

      // Actualizar barra de progreso
      progress.update(i);

      // Mostrar info del archivo actual
      console.log(`\nüìÅ Archivo actual: ${path.basename(file)}`);

      try {
        const { results, fileContext } = analyzeFile(file);

        if (results.length === 0) {
          console.log(
            '  ‚ÑπÔ∏è  No se encontraron identificadores para analizar en este archivo.'
          );
          continue;
        }

        totalItems += results.length;

        // Mostrar informaci√≥n sobre el an√°lisis
        console.log(`  üîç Se encontraron ${results.length} identificadores.`);
        console.log(`  üìÑ Contexto: ${fileContext.context || 'general'}`);

        if (fileContext.imports && fileContext.imports.length > 0) {
          console.log(
            `  üì¶ Importaciones: ${fileContext.imports.slice(0, 3).join(', ')}${
              fileContext.imports.length > 3 ? '...' : ''
            }`
          );
        }

        // Mostrar las sugerencias para cada identificador
        await showSuggestionsFor(results, fileContext, file);

        // Actualizar progreso tras completar el archivo
        progress.update(i + 1);
      } catch (error) {
        console.error(`  ‚ùå Error analizando ${file}: ${error.message}`);
      }
    }
  } finally {
    // Asegurar que la barra de progreso se complete
    progress.complete();
  }

  // Mostrar estad√≠sticas al final
  showStats(files.length, totalItems, changedItems);
}

// Funci√≥n para mostrar ayuda
function showHelp(): void {
  console.log('\nüìö Ayuda de Namer Suggester');
  console.log('=========================');
  console.log(
    'Namer Suggester es una herramienta que analiza tus archivos JavaScript/TypeScript'
  );
  console.log(
    'y sugiere mejores nombres para funciones, variables y otros identificadores.'
  );
  console.log('\nüîß Opciones principales:');
  console.log(
    '1. Analizar archivos: Selecciona archivos o directorios para analizar.'
  );
  console.log(
    '2. Configurar IA: Configura los proveedores de IA para obtener mejores sugerencias.'
  );

  console.log('\nü§ñ Proveedores de IA soportados:');
  console.log(
    '- GitHub Copilot CLI (requiere gh CLI con extensi√≥n de Copilot)'
  );
  console.log('- OpenAI (GPT-3.5/GPT-4, requiere API key)');
  console.log('- Anthropic Claude (requiere API key)');
  console.log('- Ollama (modelos locales, ejecut√°ndose en tu m√°quina)');
  console.log('- Google Gemini (requiere API key)');

  console.log('\nüìã C√≥mo usar la herramienta:');
  console.log('1. Selecciona "Analizar archivos" en el men√∫ principal');
  console.log(
    '2. Navega por la estructura de directorios o busca archivos por patr√≥n'
  );
  console.log(
    '3. Para cada identificador encontrado, revisa las sugerencias y elige la mejor'
  );
  console.log(
    '4. Todas las sugerencias se guardan en namer-suggester.log para referencia futura'
  );

  console.log('\n‚öôÔ∏è Archivo de configuraci√≥n:');
  console.log('La configuraci√≥n de IA se guarda en:');
  console.log('- .ai-config.json en tu directorio actual');
  console.log('- .namer-suggester-ai-config.json en tu directorio de usuario');
  console.log('- O en la carpeta de instalaci√≥n de la herramienta');

  console.log('\nüîç Para m√°s informaci√≥n, consulta el README.md\n');
}

// Iniciar el programa
main().catch((error) => {
  console.error('‚ùå Error fatal en la aplicaci√≥n:', error.message);
  console.error('Si este problema persiste, por favor reporta el error en:');
  console.error('https://github.com/juandape/name-suggester/issues');

  // Si hay una traza de error, mostrarla en modo depuraci√≥n
  if (process.env.DEBUG) {
    console.error('\nDetalles del error (DEBUG):', error);
  } else {
    console.log('\nPara ver m√°s detalles del error, ejecuta con DEBUG=true');
    console.log('DEBUG=true namer-suggester');
  }

  process.exit(1);
});
